---
title: 每日算法系列【LeetCode 1186】删除一次得到子数组最大和
top: false
cover: false
toc: true
mathjax: true
date: 2020-02-12 07:29:21
password:
summary:
tags:
- leetcode
- 算法
categories:
- 编程算法
---

> 关注公众号【算法码上来】，每日算法干货马上就来！

![](/medias/contact.jpg)

## 题目描述
给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。

换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。

注意，删除一个元素后，子数组 不能为空。

**示例1**
```text
输入：
arr = [1,-2,0,3]
输出：
4
解释：
我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
```

**示例2**
```text
输入：
arr = [1,-2,-2,3]
输出：
3
解释：
我们直接选出 [3]，这就是最大和。
```

**示例3**
```text
输入：
arr = [-1,-1,-1,-1]
输出：
-1
解释：
最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。
```

**提示**
* 1 <= arr.length <= 10^5
* -10^4 <= arr[i] <= 10^4

## 题解
首先回顾一道很相似的题目，也就是求连续子数组的最大值，并不需要删除元素。

这其实只需要用动态规划就能实现了，也就是计算以 $arr[i]$ 结尾的连续子数组的最大值，记为 $dp[i]$ 。那么它一定要取 $arr[i]$ ，而前面的元素的话，如果 $dp[i-1] > 0$ ，也就是以 $arr[i-1]$ 为结尾的连续子数组最大值大于 0 ，那就加上前面的最大值，否则的话只取 $arr[i]$ 就行了。最终答案就是取所有 $dp[i]$ 中最大的，状态转移方程是：
$$
dp[i] = arr[i] + max(dp[i-1], 0)
$$

回到本题，如果一个元素都不删除的话，那么做法就和上面一模一样。如果删除一个元素的话，那么它的左右两边就分成了两个连续的子数组了。

那么我们假设删除的是 $arr[i]$ ，那么我们只要求左右两边子数组的最大值之和，也就是以 $arr[i-1]$ 结尾和以 $arr[i+1]$ 开头的两个连续子数组的最大值之和。以 $arr[i-1]$ 结尾上面已经求过了，以 $arr[i+1]$ 开头和上面方法类似，从后往前求一遍就行了。这样预处理完两个动态规划数组之后，遍历删除的元素，就能 $O(n)$ 时间内算出最大值。

具体实现的时候，注意到删除的元素是有限制的，其实只需要遍历删除 $arr[1]$ 到 $arr[n-2]$ 就行了，因为删除首尾两个元素的话，剩下来一个子数组，答案已经包含在开始的预处理之中了。

空间方面，从右往左求以 $arr[i]$ 开头的连续子数组最大值的时候，没有必要保存到数组里了，直接用变量保存，然后同时计算删除 $arr[i]$ 之后最大值就行了。

## 代码
### c++
```cpp
class Solution {
public:
    int maximumSum(vector<int>& arr) {
        int n = arr.size();
        int dp[n];
        dp[0] = arr[0];
        int res = dp[0];
        for (int i = 1; i < n; ++i) {
            dp[i] = arr[i] + max(dp[i-1], 0);
            res = max(res, dp[i]);
        }
        int last = arr[n-1];
        for (int i = n-2; i > 0; --i) {
            res = max(res, dp[i-1]+last);
            last = arr[i] + max(last, 0);
        }
        return res;
    }
};
```

### python
```python
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        dp = [arr[0]] * n
        for i in range(1, n):
            dp[i] = arr[i] + max(dp[i-1], 0)
        res, last = max(dp), arr[-1]
        for i in range(n-2, 0, -1): 
            res = max(res, dp[i-1]+last)
            last = arr[i] + max(last, 0)
        return res
```

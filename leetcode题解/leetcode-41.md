---
title: 【每日算法Day 75】字节跳动面试题：手撕困难题，看过我Day 71的人都会做了！
top: false
cover: false
toc: true
mathjax: true
date: 2020-03-20 10:46:19
password:
summary:
tags:
- leetcode
- 算法
categories:
- 编程算法
---

> 关注公众号【算法码上来】，每日算法干货马上就来！

![](/medias/contact.jpg)

## 题目链接
[LeetCode 41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/ "LeetCode 41. 缺失的第一个正数")

## 题目描述
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

**示例1**
```text
输入：
[1,2,0]
输出：
3
```

**示例2**
```text
输入：
[3,4,-1,1]
输出：
2
```

**示例3**
```text
输入：
[7,8,9,11,12]
输出：
1
```

**说明：**   
* 你的算法的时间复杂度应为 $O(n)$，并且只能使用常数级别的空间。

## 题解
如果之前一直坚持看我题解的同学，应该前几天刚看过下面这道题：   
[韦阳的博客：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法](https://godweiyang.com/2020/03/16/leetcode-interview-17-19/ "韦阳的博客：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法")

[知乎专栏：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法](https://zhuanlan.zhihu.com/p/113534188 "知乎专栏：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法")

那道题是要求 $1$ 到 $n$ 中缺失的两个数，于是我们开辟一个大小为 $n$ 的数组，将所有数字放到下标对应的位置，然后看哪两个位置是空着的。为了使用原地算法，我们直接在原数组上进行操作。

回到本题，我们要寻找的是第一个缺失的正整数。其实问题的本质是一样的，如果数组的长度是 $n$ ，那么最多只能填充 $1$ 到 $n$ 这 $n$ 个正整数，所以缺失的正整数一定小于等于 $n+1$ 。

那么我们把小于等于 $0$ 或者大于 $n$ 的数全部赋值为 $-1$ ，因为它们是多少不要紧，不影响最后的结果。然后和上面题目方法一样，用原地算法，把每个数字放入对应下标的位置。最后从左到右扫描一遍数组，如果发现有位置是 $-1$ ，那么第一个缺失的正数就是它了。如果扫描完 $1$ 到 $n$ 发现全都在，那么第一个缺失的就是 $n+1$ 了。当然可能缺失很多正数，所以扫描到第一个缺失正数之后，就要直接返回结果了。

因为我们要保存 $1$ 到 $n$ 之间的数，所以数组长度不够，要在后面扩充一个才行。

时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ 。

## 代码
### c++
```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        nums.push_back(-1);
        for (int i = 0; i <= n; ++i) {
            if (nums[i] <= 0 || nums[i] > n) {
                nums[i] = -1;
            }
        }
        for (int i = 0; i <= n; ++i) {
            while (nums[i] != -1 && i != nums[i] && nums[i] != nums[nums[i]]) {
                swap(nums[i], nums[nums[i]]);
            }
            if (nums[i] != -1 && i != nums[i]) {
                nums[i] = -1;
            }
        }
        for (int i = 1; i <= n; ++i) {
            if (nums[i] == -1) return i;
        }
        return n+1;
    }
};
```

---
title: 每日算法系列【LeetCode 319】灯泡开关
top: false
cover: false
toc: true
mathjax: true
date: 2020-03-05 13:42:15
password:
summary:
tags:
- leetcode
- 算法
categories:
- 编程算法
---

> 关注公众号【算法码上来】，每日算法干货马上就来！

![](/medias/contact.jpg)

## 题目描述
初始时有 $n$ 个灯泡关闭。 第 $1$ 轮，你打开所有的灯泡。 第 $2$ 轮，每两个灯泡你关闭一次。 第 $3$ 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 $i$ 轮，每 $i$ 个灯泡切换一次开关。 对于第 $n$ 轮，你只切换最后一个灯泡的开关。 找出 $n$ 轮后有多少个亮着的灯泡。

**示例1**
```text
输入：
3
输出：
1
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。
```

## 题解
首先有 $n$ 个灯泡，假设编号为 $1$ 到 $n$ 。第 $1$ 轮，所有编号是 $1$ 的倍数的灯泡被开关了一次。第 $2$ 轮，所有编号是 $2$ 的倍数的灯泡被开关了一次。类推下去，第 $i$ 轮，所有编号是 $i$ 的倍数的灯泡被开关了一次。

综上，对于编号为 $i$ 的灯泡来说，它最终被开关的次数取决于 $i$ 有几个因数。如果有奇数个因数，那么它最后就是开着的，否则就是关着的。

那么我们有一个定理：**如果一个正整数有奇数个因数，那么它一定是完全平方数**。

最浅显的证明就是，一个数 $i$ 的因数按照从小到大排个序，首尾两两一对之积一定等于 $i$ 。而如果因数只有奇数个，最中间一个因数 $x$ 只会出现一次，那么 $i = x^2$ 。

严格证明也不难，首先将 $i$ 质因数分解为：
$$
i = p_1^{c_1}p_2^{c_2}\cdots p_k^{c_k}
$$
那么 $i$ 的因数个数就是：
$$
(c_1+1)(c_2+1)\cdots (c_k+1)
$$
因为 $i$ 的因数个数是奇数，所以任意 $c_j + 1$ 必定是奇数，即任意 $c_j$ 必定是偶数。

那么 $i$ 就可以写作：
$$
i = (p_1^{c_1/2}p_2^{c_2/2}\cdots p_k^{c_k/2})^2
$$
这就证明了 $i$ 一定是一个完全平方数。

所以问题就转化为了**求 $1$ 到 $n$ 之间有多少个完全平方数**。答案就是 $\left\lfloor\sqrt{n}\right\rfloor$ 。

在具体实现的时候，为了防止出现浮点数误差（比如 $\sqrt{9}$ 算出来是 $2.9999$ ，取整得到 $2$），我们可以计算 $\left\lfloor\sqrt{n+0.5}\right\rfloor$ 的结果。

## 代码
### c++
```cpp
class Solution {
public:
    int bulbSwitch(int n) {
        return sqrt(n+0.5);
    }
};
```

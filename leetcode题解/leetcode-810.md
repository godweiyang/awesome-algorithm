---
title: 每日算法系列【LeetCode 810】黑板异或游戏
top: false
cover: false
toc: true
mathjax: true
date: 2020-01-27 13:45:07
password:
summary:
tags:
- leetcode
- 算法
categories:
- 编程算法
---

> 关注公众号【算法码上来】，每日算法干货马上就来！

![](/medias/contact.jpg)

## 题目描述
一个黑板上写着一个非负整数数组 nums[i] 。小红和小明轮流从黑板上擦掉一个数字，小红先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）

换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。

假设两个玩家每步都使用最优解，当且仅当小红获胜时返回 true。

**示例1**
```text
输入：
nums = [1, 1, 2]
输出：
false
解释：
小红有两个选择: 擦掉数字 1 或 2。
如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么小明可以擦掉任意数字，因为小红会成为擦掉最后一个数字的人，她总是会输。
如果小红擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。小红仍然会输掉游戏。
```

**提示**
* 1 <= N <= 1000
* 0 <= nums[i] <= 2^16

## 题解
小红获胜的条件就是，某一步轮到她的时候，所有数异或等于 0 。

而反过来，她输的条件就是，面对 n 个数，无论她选哪个数，去掉这个数之后剩下的数的异或都等于 0 。

假设 n 个数的异或为 S ，也就是令：
$$
S = x_1 \oplus x_2 \oplus \dots \oplus x_n
$$
因为两个相同的数的异或为 0 ，所以去掉任意一个数 $x_i$ 之后的异或为 $S \oplus x_i = 0$ ，所以 $S = x_i$ ，也就是所有的数都相等。

此时如果 n 是偶数，那么 n 个数的异或必为 0 ，和小红必输矛盾了，所以 n 一定要是奇数。

也就是说，如果 n 是偶数，那么小红总有办法去掉一个数，然后使得剩下的数异或不为 0 ，这时小明就没办法获胜。而不管小明擦除哪个数，轮到小红的时候个数又变成了偶数，小红就可以继续不输擦除下去。直到最后，一定是小红面对着空的数集，最终获胜。

而 n 是奇数的时候，无论小红选什么数，小明面对的都是偶数个数，那么小明必胜。

综上，n 是偶数小红必胜，或者刚开始 n 个数异或就是 0 ，这样不管奇偶，小红都能获胜。

## 代码
### c++
```cpp
class Solution {
public:
    bool xorGame(vector<int>& nums) {
        if (!(nums.size()&1)) return true;
        int x = 0;
        for (auto i : nums) x ^= i;
        return !x;
    }
};
```

### python
```python
from functools import reduce

class Solution:
    def xorGame(self, nums: List[int]) -> bool:
        return (len(nums)&1) == 0 or reduce(operator.xor, nums) == 0
```

## 后记
官方题解是这么说的：如果 n 是偶数，那么小红有很大概率获胜，因为如果游戏能够一直进行下去，小明将会是擦除最后一个数的人，轮到小红时黑板上已经没有数，小红获胜。然后再推测 n 是偶数情况下的必胜条件，但是这样带有一点先猜后验证的成分。

所以我的推测方法直接从必胜条件出发，推测出 n 是偶数，这样过渡自然，更符合思考的路线。
---
title: 每日算法系列【LeetCode 188】买卖股票的最佳时机 IV
top: false
cover: false
toc: true
mathjax: true
date: 2020-02-27 20:26:13
password:
summary:
tags:
- leetcode
- 算法
categories:
- 编程算法
---

> 关注公众号【算法码上来】，每日算法干货马上就来！

![](/medias/contact.jpg)

## 题目描述
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例1**
```text
输入：
[2,4,1], k = 2
输出：
2
解释：
在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例2**
```text
输入：
[3,2,6,5,0,3], k = 2
输出：
7
解释：
在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

## 题解
这是 **【买卖股票的最佳时机】** 系列题目的第四题。

这题是最一般的情况了，也就是最多可以买卖 $k$ 次。那么我们采用动态规划来求解。

令 $dp0[i][j]$ 为第 $i$ 只股票之前（包含）买卖 $j$ 次（且最后一次操作为**买入**）可以获得的最大利润，$dp1[i][j]$ 为第 $i$ 只股票之前（包含）买卖 $j$ 次（且最后一次操作为**卖出**）可以获得的最大利润。

那么对于 $dp0[i][j]$ 来说，最后一次操作是买入，所以分为两种情况。
* 一种是不买第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为买入）的最大利润：
$$dp0[i][j] = dp0[i-1][j]$$
* 一种是买第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j-1$ 次（且最后一次操作为卖出）的最大利润：
$$dp0[i][j] = dp1[i-1][j-1] - price[i]$$

而对于 $dp1[i][j]$ 来说，最后一次操作是卖出，所以分为两种情况。
* 一种是不卖第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为卖出）的最大利润：
$$dp1[i][j] = dp1[i-1][j]$$
* 一种是卖第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为买入）的最大利润：
$$dp1[i][j] = dp0[i-1][j] + price[i]$$

综上转移方程就是：
$$
\begin{aligned}
dp0[i][j] &= \max{\left\{dp0[i-1][j], dp1[i-1][j-1] - price[i]\right\}} \\\
dp1[i][j] &= \max{\left\{dp1[i-1][j], dp0[i-1][j] + price[i]\right\}}
\end{aligned}
$$

初始情况就是 $n = 0$ 和 $k = 0$ 时，单独计算一下就行了。

此外本题还可以优化成一维数组，就不展开介绍了，大家可以参考代码。

时间复杂度是 $O(nk)$ 。

## 代码
### python
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        if k >= n//2:
            res = 0
            for i in range(1, n):
                res += max(prices[i]-prices[i-1], 0)
            return res
        dp0 = [-prices[0]] * (k+1)
        dp1 = [0] * (k+1)
        for p in prices[1:]:
            for i in range(1, k+1):
                dp1[i] = max(dp1[i], dp0[i]+p)
                dp0[i] = max(dp0[i], dp1[i-1]-p)
        return max(dp1[k], 0)
```